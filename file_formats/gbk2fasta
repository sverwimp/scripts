#!/usr/bin/env python3

import argparse
import bz2
import gzip
import sys
import re


def is_gzipped(path):
    with open(path, "rb") as f:
        return f.read(2) == b"\x1f\x8b"
    

def is_bzipped(path):
    with open(path, "rb") as f:
        return f.read(3) == b"BZh"


def open_file(path, mode="rt"):
    if is_gzipped(path):
        return gzip.open(path, mode)
    elif is_bzipped(path):
        return bz2.open(path, mode)
    return open(path, mode)


def write_fasta(data: tuple, width: int = 60) -> str:
    """Takes a (header, sequence) tuple and returns a FASTA formatted string."""
    header, sequence = data
    fasta_str = f">{header}\n"
    for i in range(0, len(sequence), width):
        fasta_str += sequence[i:i+width] + "\n"
    return fasta_str


def parse_nucleotide(path):
    record = {"seqid": None, "sequence": []}
    state = "HEADER"
    for line in open_file(path, "rt"):
        line = line.rstrip()
        if line.startswith("LOCUS"):
            record["seqid"] = line.split()[1]
        elif line.startswith("ORIGIN"):
            state = "ORIGIN"
        elif line.startswith("//"):
            # End of record
            if record["seqid"] and record["sequence"]:
                yield (record["seqid"], "".join(record["sequence"]).replace(" ", "").replace("\n", ""))
            record = {"seqid": None, "sequence": []}
            state = "HEADER"
        elif state == "ORIGIN":
            record["sequence"].append(re.sub(r"[^acgtACGTnN]", "", line).upper())


def parse_protein(path):
    """Assumes each CDS feature has a 'translation' attribute!"""
    record = {"seqid": None, "features": [], "sequence": []}
    current_feat = None
    current_qual = None
    state = "HEADER"

    for line in open_file(path, "rt"):
        line = line.rstrip()
        if not line: continue
        if line.startswith("LOCUS"):
            record["seqid"] = line.split()[1]
        elif line.startswith("FEATURES"):
            state = "FEATURES"
        elif line.startswith("ORIGIN"):
            state = "ORIGIN"
        elif line.startswith("//"):
            # End of record
            for feat in record["features"]:
                attrs = feat.get("attrs")
                # Skip pseudo genes, have no "translation" attribute
                if "pseudo" in attrs:
                    continue

                gene = attrs.get("gene", "")
                locus_tag = attrs.get("locus_tag", "")
                product = attrs.get("product", "")
                translation = attrs.get("translation", "")
                location = feat.get("loc", "")
                
                header_parts = []
                if gene:
                    header_parts.append(gene)
                if locus_tag:
                    tag_part = f"[{locus_tag}]" if gene else locus_tag
                    header_parts.append(tag_part)
                if product:
                    header_parts.append(f"[{product}]")
                if location:
                    header_parts.append(f"[{record['seqid']}:{location}]")
                header = " ".join(header_parts) if header_parts else locus_tag or "unknown"
                
                if translation:
                    translation = translation.replace(" ", "").replace("\n", "").upper()
                else:
                    raise ValueError(f"Translation not found for {gene if gene else locus_tag}")

                yield (header, translation)

            record = {"seqid": None, "features": [], "sequence": []}
            current_feat = None
            current_qual = None
            state = "HEADER"

        elif state == "FEATURES":
            if line.startswith(" " * 5) and not line.startswith(" " * 21):
                parts = line.split()
                if len(parts) >= 2:
                    feat_type = parts[0]
                    if feat_type != "CDS": # Only keep CDS features
                        continue
                    current_feat = {"type": feat_type, "loc": parts[1], "attrs": {}}
                    record["features"].append(current_feat)
                    current_qual = None
            elif line.startswith(" " * 21) and current_feat is not None:
                content = line.strip()
                if content.startswith("/"):
                    if "=" in content:
                        key, val = content[1:].split("=", 1)
                        val = val.strip('"')
                        current_feat["attrs"][key] = val
                        current_qual = key
                    else:
                        current_feat["attrs"][content[1:]] = True
                        current_qual = content[1:]
                elif current_qual:
                    current_feat["attrs"][current_qual] += " " + content.strip('"')


def main(path: str, protein: bool = False):
    gbk_parser = parse_protein if protein else parse_nucleotide
    yield from gbk_parser(path)


if __name__ == "__main__":
    parser = argparse.ArgumentParser(
        description="Convert GenBank file to FASTA format.",
        formatter_class=argparse.RawTextHelpFormatter
    )
    parser.add_argument("genbank", nargs="?", help="Input GenBank file (can be gzipped or bzipped). If not provided, reads from stdin.")
    parser.add_argument("-p", "--protein", action="store_true", help="Output protein sequences instead of nucleotide sequences")
    parser.add_argument("-o", "--out", help="Output FASTA file (default: stdout)")
    parser.add_argument("-w", "--width", type=int, default=60, help="Line width for FASTA output (default: 60)")
    args = parser.parse_args()

    if args.genbank:
        input_path = args.genbank
    else:
        input_path = sys.stdin.read().strip()
        if not input_path:
            parser.error("No input GenBank file provided.")

    out = open(args.out, "w") if args.out else sys.stdout

    try:
        results = main(input_path, args.protein)
        for result in results:
            out.write(write_fasta(result, width=args.width))
    except BrokenPipeError:
        devnull = open('/dev/null', 'w')
        sys.stdout = devnull
    finally:
        if args.out: out.close()
    